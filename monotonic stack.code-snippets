"monotonic stack": {
  "prefix": "monotonic stack",
  "body": [
    "template < typename T = int > struct monotonic stack{",
    "  ",
    "  T n;",
    "  vector < T > v;",
    "  vector < T > ans;",
    "  vector < pair < T, T > > st;",
    "",
    "  monotonic stack(vector < T > &v) : v(v) {",
    "    n = sz(v);",
    "    ans = vector < T > (n);",
    "  }",
    "  ",
    "  // function to get the next greater if no greater element return -1",
    "  vector < T > next_greater_element(){",
    "    for(int i = n - 1; i >= 0; i--){",
    "      while(!st.empty() && st.back().first <= v[i]) st.pop_back();",
    "      ans[i] = (st.empty() ? -1 : st.back().second);",
    "      st.push_back({v[i], i});",
    "    }",
    "    return ans;",
    "  }",
    "",
    "  // function to get the previous greater if no greater element return -1",
    "  vector < T > prev_greater_element(){",
    "    for(int i = 0; i < n; i++){",
    "      while(!st.empty() && st.back().first <= v[i]) st.pop_back();",
    "      ans[i] = (st.empty() ? -1 : st.back().second);",
    "      st.push_back({v[i], i});",
    "    }",
    "    return ans;",
    "  }",
    "",
    "  // function to get the next smaller if no smaller element return -1",
    "  vector < T > next_smaller_element(){",
    "    for(int i = n - 1; i >= 0; i--){",
    "      while(!st.empty() && st.back().first >= v[i]) st.pop_back();",
    "      ans[i] = (st.empty() ? -1 : st.back().second);",
    "      st.push_back({v[i], i});",
    "    }",
    "    return ans;",
    "  }",
    "",
    "  // funtion to get the previous smaller if no smaller element return -1",
    "  vector < T > prev_smaller_element(){",
    "    for(int i = 0; i < n; i++){",
    "      while(!st.empty() && st.back().first >= v[i]) st.pop_back();",
    "      ans[i] = (st.empty() ? -1 : st.back().second);",
    "      st.push_back({v[i], i});",
    "    }",
    "    return ans;",
    "  }",
    "",
    "",
    "};"
  ],
  "description": "monotonic stack"
}
