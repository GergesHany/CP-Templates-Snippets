{
  "Modulo multiplicative inverse": {
    "prefix": "Modulo multiplicative inverse",
    "body": [
      "// Modulo multiplicative inverse",
      "template < typename T = int > struct Modulo_multiplicative_inverse{",
      " ",
      "  Modulo_multiplicative_inverse() = default;",
      " ",
      "  T n, r, Mod;",
      "  vector < T > fact, inv_fact;",
      " ",
      "  auto take_mod(T a, T b) -> ll {",
      "     return (a % mod * b % mod) % mod;",
      "  }",
      " ",
      "  Modulo_multiplicative_inverse(T n, T r, T Mod) : n(n), r(r), Mod(Mod) {",
      "    fact = vector < T > (n + 1, 1);",
      "    inv_fact = vector < T > (n + 1, 1);",
      "    for (T i = 1; i <= n; i++) {",
      "      fact[i] = take_mod(fact[i - 1], i);",
      "      inv_fact[i] = Modulo_Inverse(fact[i]);",
      "    }",
      "  }",
      " ",
      "  T fast_power(T a, T b){",
      "    T res = 1;",
      "    while (b){",
      "      if (b & 1) res = take_mod(res, a);",
      "      a = take_mod(a, a);",
      "      b >>= 1;",
      "    }",
      "    return res;",
      "  }",
      "  ",
      "  // fact[n] / (fact[r] * fact[n - r]) = fact[n] * (fact[r] * fact[n - r])^-1 = fact[n] * inv_fact[r] * inv_fact[n - r]",
      "  T nCr(T n, T r){",
      "    if (n < r) return 0;",
      "    return take_mod(fact[n], take_mod(inv_fact[r], inv_fact[n - r]));",
      "  }",
      " ",
      "  // fact[n] / fact[n - r] = fact[n] * (fact[n - r])^-1 = fact[n] * inv_fact[n - r] ",
      "  T nPr(T n, T r){",
      "    if (n < r) return 0;",
      "    return take_mod(fact[n], inv_fact[n - r]);",
      "  }",
      " ",
      "  T Modulo_Inverse(T a){",
      "    return fast_power(a, Mod - 2);",
      "  }",
      " ",
      "};"
    ],
    "description": "Modulo multiplicative inverse"
  }
}

